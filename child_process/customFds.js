// spawn()还可以接受一个配置对象作为最后一个参数
//  env 、setsid和cwd属性都是spawn()的可选项
//  uid和gid, 分别用来设置用户ID和组ID
// 将uid和gid直接设置为用户名或用户组的名称
// 会因为进一步查找id而短暂堵塞
// stdio属性可以设置自定义的文件描述符
// 来传给新建立的子进程

// 关于Unix系统中的文件描述符：
// 用来记录跟踪该程序正在对哪些文件进行操作的方法
// Unix允许多个程序同时运行
// 需要有方法来确保这些程序在修改文件系统
// 时不会不小心把别人的修改覆盖
// 文件描述符表是用来记录一个进程想要访问的所有文件信息的
// 内核可能会为了防止两个程序同时修改一个文件而把某个特定的文件锁住
// 进程会从文件描述符表中查找某个文件对应的文件描述符
// 然后传给内核去访问该文件
// 文件描述符其实只是用一个整数来表示
// 它并不是单纯地表示文件
// 网络或其他socket一类的东西也是分配成文件描述符

// Unix的跨进程通信(IPC)socket
// 可以让进程间互相发消息
// 我们称它们为stdin,stdout和stderr
// 文件描述符0、1、2分别代表了stdin、stdout和stderr    

// 当spawn()在创建新的子进程时指定文件描述符时
// 就不必由操作系统指派一个新的文件描述符
// 子进程与父进程一起共享已经存在的文件描述符
// 它可以是一个连接在互联网上的网络socket
// 或者只是父进程的stdin

//  这样做的好处是
// 比起用Node的stream.pipe()把数据流连接起来
// 直接通过操作系统内核来分发要快很多
// 一个常见的使用情境是把
// 网络socket和一组子进程相连接,
// 来利用多核的性能

const child_process = require('child_process')

const cat = child_process.spawn('cat', [], {
    // 把父进程的stdin、stdout和stderr传给子进程
    // 与此同时，子进程就丢失了它的
    // child.stdin、child.stdout和child.stderr
    // 文件描述符引用
    stdio: [0, 1, 2],
})
